Лабораторная работа № 9–10
Тема: Дополнительные алгоритмы сортировки и поиска
Как я понял, цель задания:
Применить навыки анализа алгоритмов (сортировки и поиска), изученные ранее.
Разобрать новые алгоритмические структуры, понять их суть и сложность.
Научиться самостоятельно писать, тестировать и анализировать новые алгоритмы в онлайн-среде разработки.
Уметь оформлять работу на GitHub: аналитика в README, код в папке Code/.
Алгоритмы сортировки
1. Блочная сортировка (Bucket Sort)
Определение
Bucket Sort — распределяет элементы по нескольким «корзинам» в зависимости от диапазона значений. Каждая корзина сортируется отдельно, затем корзины объединяются.

Объяснение работы алгоритма
Находим минимальный и максимальный элементы, определяем диапазон.
Создаём k пустых корзин.
Для каждого элемента вычисляем индекс корзины по формуле распределения.
Складываем элементы в соответствующие корзины.
Сортируем содержимое каждой корзины (например, с помощью встроенной сортировки).
Собираем итоговый массив в порядке корзин.
Сложность
В среднем: O(n)
В худшем случае: O(n²) (если почти все элементы попадут в одну корзину)
Почему такая сложность
Если данные распределены равномерно, корзины маленькие → сортировка внутри них не требует больших затрат → линейная сложность.
Если распределение неравномерное, корзина одна → обычная сортировка → O(n²).

2. Блинная сортировка (Pancake Sort)
Определение
Алгоритм, который сортирует массив с помощью единственной операции — переворота (reverse) префикса массива.

Как работает
Находим максимальный элемент в неотсортированной части массива.
Переворачиваем подмассив так, чтобы максимум оказался в начале.
Переворачиваем подмассив нужной длины, чтобы максимум переместился в конец.
Повторяем для оставшейся части.
Сложность
O(n2)
Почему такая сложность
На каждом шаге два переворота и один поиск максимума → O(n). Таких шагов n → O(n²).

3. Сортировка бусинами (Bead Sort / Gravity Sort)
Определение
Имитация физической модели падения бусин на стержнях: значение элемента представляется количеством бусин, которые под действием «гравитации» выстраиваются вниз.

Как работает
Каждое число превращается в строку бусин (столько бусин, как значение числа).
Бусины падают вниз, как в абаке.
После оседания структуры считываем итоговые строки — получаем отсортированный массив.
Сложность
Теоретическая: O(n)
Реальная (в программной модели): O(n · max_value)
Почему такая сложность
Работа зависит не только от n, но и от диапазона значений, потому что нужно создавать конструкции из «бусин» длиной max_value.

Алгоритмы поиска
4. Поиск по скачкам (Jump Search)
Определение
Оптимизация линейного поиска для отсортированных массивов: массив делится на блоки длиной √n, и алгоритм «перескакивает» с блока на блок.

Как работает
Вычисляется шаг: step = sqrt(n).
Алгоритм перескакивает через step элементов, пока не найдёт блок, превышающий target.
В найденном блоке выполняется обычный линейный поиск.
Сложность
O(√n)
Почему такая сложность
Количество прыжков = n / шаг.
Линейный поиск внутри блока = шаг.
Оптимальный шаг — sqrt(n), отсюда итоговое значение O(√n).

5. Экспоненциальный поиск (Exponential Search)
Определение
Комбинация последовательного увеличения индекса (1, 2, 4, 8, …) и бинарного поиска внутри найденного диапазона.

Как работает
Проверяем первый элемент.
Экспоненциально увеличиваем индекс, пока не достигнем цели.
В найденном интервале запускаем бинарный поиск.
Сложность
O (логарифмическое число n)
Почему такая сложность
Фаза экспоненциального поиска занимает O(log n) (поскольку выполняются шаги 1, 2, 4, 8...).
Бинарный поиск тоже занимает O(log n).
Суммарно также O(log n).

6. Тернарный поиск (Ternary Search)
Определение
В отличие от бинарного поиска, этот метод делит диапазон на три части и сравнивает элемент сразу с двумя точками — mid1 и mid2.

Как работает
Находим mid1 и mid2, которые делят текущий диапазон на три части.
Если target равен одному из них — найдено.
В противном случае выбираем одну из трёх частей и повторяем.
Сложность
O (логарифмическое число n)
Почему такая сложность
Хотя деление происходит на три части, количество сравнений на итерацию увеличивается, но глубина рекурсии примерно логарифмическая.
Преимуществ перед бинарным поиском почти нет.

